//
// Name: Clock
// Description: A fullscreen overlay of the current time in the real world.
//

/* @ToDo
 * Update atmosphereic conditions based on actual weather conditions. 
 * Rain notification
 * Jacket notification
 */

include("location.js"); 
include("suncalc.js");

visible = true;
invisible = false;
v_fov = 30;
h_fov = v_fov*1.75; //Estimating Horizontial FOV. Assumes screen aspect ration of 2:1
displayed_time = "";
tock = true;

//     core.debug('h_fov = ' + h_fov);

//Nice flat horizon
core.setProjectionMode("ProjectionPerspective");

//Hide things
core.setGuiVisible(invisible);
try {
    LandscapeMgr.setFlagIllumination(false);
    LandscapeMgr.setFlagLabels(false);
    LandscapeMgr.setFlagCardinalsPoints(false);
    MeteorShowers.setEnableLabels(false);
    Satellites.setFlagLabels(false);
} catch(e) {/*Ignore Failure*/}
//Set the display options
core.clear("natural");
//Setup default view
core.setObserverLocation(lon, lat, alt, 0, place, "");
StelMovementMgr.setInitFov(v_fov);
StelMovementMgr.setMaxFov(v_fov);

//Setup Sun Tracking
core.selectObjectByName("Sun", false);
sun = core.getSelectedObjectInfo();

//StelMovementMgr.setFlagTracking(true);
//Find the furthest east and west the sun will go while visible.
//https://astronomy.stackexchange.com/questions/24598/how-to-calculate-the-maximum-and-minimum-solar-azimuth-at-a-given-location
sunrise_max = 180.0 - degrees(Math.acos(-Math.sin(radians(23.5))/Math.cos(radians(lat))));
sunset_max = 180.0 + degrees(Math.acos(-Math.sin(radians(23.5))/Math.cos(radians(lat))));
max_azimuth_range = sunset_max - sunrise_max;
// core.debug('sunrise_max = ' + sunrise_max);
// core.debug('sunset_max = ' + sunset_max);
// core.debug('max_azimuth_range = ' + max_azimuth_range);

//Setup Sunset/Sunrise Countdown
var suntime = suntimes(90.833);
// core.debug('sun_declin_deg: ' + suntime.sun_declin_deg);
// core.debug('solar_noon: ' + suntime.solar_noon);
// core.debug('sunup: ' + suntime.sunup);
// core.debug('sundown: ' + suntime.sundown);

//Expects start and end in "web" hex strings (i.e. #FFFFFF)
//Performs a 1D Linear fade between the two colors.
function color_fade(start, end, percent) {
    return "#" + 
                ("0"+(parseInt(start.substring(1,3), 16) + Math.round(percent*(parseInt(end.substring(1,3), 16) - parseInt(start.substring(1,3), 16)))).toString(16)).slice(-2) + //Red
                ("0"+(parseInt(start.substring(3,5), 16) + Math.round(percent*(parseInt(end.substring(3,5), 16) - parseInt(start.substring(3,5), 16)))).toString(16)).slice(-2) + //Green
                ("0"+(parseInt(start.substring(5,7), 16) + Math.round(percent*(parseInt(end.substring(5,7), 16) - parseInt(start.substring(5,7), 16)))).toString(16)).slice(-2);  //Blue
}

function get_display_time() {
    current_time = new Date;
    //Update Sunrise/Sunset times after midnight.
    if (suntime.sundown.getDay() != current_time.getDay()) {
        suntime = suntimes(90.833);
    }
    seconds_till_sunset = Math.floor(suntime.sundown.getTime()/1000)-Math.floor((new Date()).getTime()/1000);
    seconds_till_sunrise = Math.floor(suntime.sunup.getTime()/1000)-Math.floor((new Date()).getTime()/1000);
    hours = (current_time.getHours()>12?current_time.getHours() - 12: current_time.getHours());
    minutes = current_time.getMinutes();
    seconds = current_time.getSeconds();
    display_time = (hours<10?(hours==0?"12":" "+hours):hours)+":"+(minutes<10?"0":"")+minutes;//+":"+seconds;
    return display_time;
}

function get_display_color() {
    current_time = new Date;
    current_month = current_time.getMonth() + 1;
    
    if (current_month == 12) { //Christmas Colors
        if (sun["altitude"] > 0) {
            return color_fade("#B3000C", "#0D5901", sun["altitude"]/90);
        } else if (sun["altitude"] > -18) { //-18 is the marker for Astronomical Twilight
            return color_fade("#00B32C", "#B3000C", (-sun["altitude"])/18);
        } else {
            return "#B3000C";
        }
    } else { //"Standard" Colors
        if (sun["altitude"] > 0) {
            return color_fade("#1E73BE", "#000000", sun["altitude"]/90);
        } else if (sun["altitude"] > -18) { //-18 is the marker for Astronomical Twilight
            return color_fade("#FFFFFF", "#1E73BE", (-sun["altitude"])/18);
        } else {
            return "#1E73BE";
        }
    }
}

function wait_till_next_tick() {
    //Wait is relative to Sim Time not Real time, try and tick exactly on the second.
    if (Math.round(core.getTimeRate()) == 0) {
        //Sim Time frozen. Resort to 1 second waits.
        /*core.debug((tock?"Tock ":"Tick ")+
        "Next "+(!tock?"Tock ":"Tick ")+" in 1 second (Time Currently Paused)");
        */
        core.wait(1);
    } else {
        wait_len = Math.abs((1*core.getTimeRate())/(core.getTimeRate()<=18 && core.getTimeRate()>=-18?core.getTimeRate():18));
        tock = !tock;
        /*core.debug((tock?"Tock ":"Tick ")+
                "Next "+(!tock?"Tock ":"Tick ")+" in "+(core.getTimeRate()<0?"- ":"+ ")+wait_len+' "seconds" '+
                'at roughly '+Math.abs(core.getTimeRate()<=18 && core.getTimeRate()>=-18?core.getTimeRate():18)+" fps");
*/
        core.waitFor((core.getTimeRate()<0?"- ":"+ ")+wait_len+" seconds", "utc");
    }
}

function update_view() {
    core.selectObjectByName("Sun", false);
    sun = core.getSelectedObjectInfo();

/*    StelSkyDrawer.setExtinctionCoefficient (double extCoeff)
 	Set extinction coefficient, mag/airmass (for extinction).
 
    StelSkyDrawer.setAtmosphereTemperature (double celsius)
 	Set atmospheric (ground) temperature in deg celsius (for refraction).
 
    StelSkyDrawer.setAtmospherePressure (double mbar)
    Get atmospheric (ground) pressure in mbar (for refraction)
*/
    viewport_offset = 50 - (((sun["azimuth"] - sunrise_max)/max_azimuth_range)*100);
//    core.debug('viewport_offset = ' + viewport_offset);
    StelMovementMgr.setViewportHorizontalOffsetTarget(viewport_offset);
    StelMovementMgr.setViewportVerticalOffsetTarget(0);

//    core.moveToAltAzi(sun["altitude"], sun["azimuth"], 0);
    core.moveToAltAzi(10, sun["azimuth"], 0);
}
//Update where the viewer is pointed
update_view();

wait_till_next_tick();

while (true) {
    update_view();
    //LabelMgr.labelHorizon("text", Azimuth, Altitude, visibility, font size, color);
    //LabelMgr.labelScreen("text", x, y, visibility, font size, color);
    if (displayed_time != get_display_time()) {
        if (typeof time_display !== 'undefined') {
            LabelMgr.deleteLabel(time_display);
        }
        time_left = 60500 - ((new Date).getSeconds()*1000) - (new Date).getMilliseconds();
        time_display = LabelMgr.labelScreen(get_display_time(), -7, -33, visible, 280, get_display_color(), true, time_left);
        
        displayed_time = get_display_time();

        seconds_till_sunset = Math.floor(suntime.sundown.getTime()/1000)-Math.floor((new Date()).getTime()/1000);
        if (typeof sunset_countdown !== 'undefined') {
            LabelMgr.deleteLabel(sunset_countdown);
        }
        if (seconds_till_sunset > 0 && seconds_till_sunset < 60*60) {
            if (Math.floor(seconds_till_sunset/60) > 50) {
                sun_phase = "â˜€";
            } else if (Math.floor(seconds_till_sunset/60) > 40) {
                sun_phase = "ðŸŒ‘";
            } else if (Math.floor(seconds_till_sunset/60) > 30) {
                sun_phase = "ðŸŒ’";
            } else if (Math.floor(seconds_till_sunset/60) > 20) {
                sun_phase = "ðŸŒ“";
            } else if (Math.floor(seconds_till_sunset/60) > 10) {
                sun_phase = "ðŸŒ”";
            } else {
                sun_phase = "ðŸŒ•";
            }
            sunset_countdown = LabelMgr.labelScreen(sun_phase, 0, 300, visible, 72, "#EEE4A7", true, time_left);
        } 
        seconds_till_sunrise = Math.floor(suntime.sunup.getTime()/1000)-Math.floor((new Date()).getTime()/1000);
        if (typeof sunrise_countdown !== 'undefined') {
            LabelMgr.deleteLabel(sunrise_countdown);
        }
        if (seconds_till_sunrise > 0 && seconds_till_sunrise < 60*60) {
            if (Math.floor(seconds_till_sunrise/60) > 50) {
                sun_phase = "ðŸŒ•";
            } else if (Math.floor(seconds_till_sunrise/60) > 40) {
                sun_phase = "ðŸŒ–";
            } else if (Math.floor(seconds_till_sunrise/60) > 30) {
                sun_phase = "ðŸŒ—";
            } else if (Math.floor(seconds_till_sunrise/60) > 20) {
                sun_phase = "ðŸŒ˜";
            } else if (Math.floor(seconds_till_sunrise/60) > 10) {
                sun_phase = "ðŸŒ‘";
            } else {
                sun_phase = "â˜€";
            }
            sunrise_countdown = LabelMgr.labelScreen(sun_phase, 600, 300, visible, 72, "#EEE4A7", true, time_left);
        } 
    }
    //Always tick at least once a second to prevent large jumps of background.
    wait_till_next_tick();
}